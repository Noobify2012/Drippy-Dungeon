package controller;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

import model.Direction;
import model.Dungeon;
import model.DungeonImpl;
import model.Player;
import model.PlayerImpl;
import model.Updater;
import random.RandomNumberGenerator;
import view.BuildStructure;
import view.IdungeonView;

/**
 * The controller for the view as part of the graphical version of the dungeon adventure game.
 */
public class ViewController implements Vcontroller, ActionListener, KeyListener {
  private int currentSeed;
  private Dungeon dungeon;
  private IdungeonView view;
  private String startString;
  private Updater startUpdate;
  private Enum<ActionEnum> actionEnum;
  private Direction direction;
  private Enum<PickupEnum> pickup;
  private int distance;
  private RandomNumberGenerator rand;


  /**The constructor for the controller for the view  which has the same two methods of buildDungeon
   * as well as playGame. It also has methods to restart the game which supports resetting the view
   * as well as keyboard, mouse and button press actions.
   *
   * @param dungeon the default dungeon that is created in the driver to kick off the game. The
   *                     player can then go in and change the dungeon by either building a new
   *                     dungeon with different parameters or with the same parameters but a
   *                     different configuration or restart the same dungeon.
   * @param view the view generated by the driver which will be used throughout the entire
   *             operation of the graphical game.
   */
  public ViewController(Dungeon dungeon, IdungeonView view) {
    if (dungeon == null || view == null) {
      throw new IllegalArgumentException("the model or view cannot be null");
    }
    this.dungeon = dungeon;
    this.currentSeed = dungeon.getSeed();
    this.view = view;
    this.actionEnum = ActionEnum.NONE;
    this.direction = Direction.NONE;
    this.pickup = PickupEnum.NONE;
    this.distance = 0;
    this.rand = new RandomNumberGenerator(0);
  }

  @Override
  public void buildDungeon() {
    this.startString = dungeon.getDungeon();
    this.startUpdate = dungeon.getStatusUpdater();
    view.updateStatus(this.startString);
    view.getUpdater(dungeon.getStatusUpdater());
    this.view.makeVisible();
    this.view.refresh();
    this.view.resetFocus();
    playGame(this.dungeon, this.view);

  }

  @Override
  public void playGame(Dungeon dungeon, IdungeonView view) {
    if (dungeon == null) {
      throw new IllegalArgumentException("The model cannot be null");
    }
    if (view == null) {
      throw new IllegalArgumentException("The view cannot be null");
    }
    this.view.refresh();

    view.setListeners(this, this);
    view.resetFocus();
    view.makeVisible();
    view.refresh();
  }


  /**
   * Invoked when an action occurs.
   *
   * @param e the event to be processed
   */
  @Override
  public void actionPerformed(ActionEvent e) {
    switch (e.getActionCommand()) {
      case "North Button":
        if (direction == Direction.NONE) {
          this.direction = Direction.NORTH;
        } else {
          this.direction = Direction.NONE;
        }
        view.resetFocus();
        break;
      case "South Button":
        if (direction == Direction.NONE) {
          this.direction = Direction.SOUTH;
        } else {
          this.direction = Direction.NONE;
        }
        view.resetFocus();
        break;

      case "East Button":
        if (direction == Direction.NONE) {
          this.direction = Direction.EAST;
        } else {
          this.direction = Direction.NONE;
        }
        view.resetFocus();
        break;

      case "West Button":
        view.resetFocus();
        if (direction == Direction.NONE) {
          this.direction = Direction.WEST;
        } else {
          this.direction = Direction.NONE;
        }
        view.resetFocus();
        break;

      case "Move Button":
        if (actionEnum == ActionEnum.NONE) {
          this.actionEnum = ActionEnum.MOVE;
          try {
            if (!this.dungeon.isGameOver()) {
              String moveString = dungeon.movePlayer(direction);
              view.updateStatus(moveString);
              view.getUpdater(dungeon.getStatusUpdater());
            }
            this.direction = Direction.NONE;
            this.actionEnum = ActionEnum.NONE;
            view.makeVisible();
            view.refresh();
            view.resetFocus();
          } catch (IllegalArgumentException iae) {
            this.actionEnum = ActionEnum.NONE;
            this.direction = Direction.NONE;
            this.pickup = PickupEnum.NONE;
          }
        }

        this.actionEnum = ActionEnum.NONE;
        this.pickup = PickupEnum.NONE;
        this.direction = Direction.NONE;
        view.resetFocus();
        break;

      case "Shoot Button":
        view.resetFocus();
        if (actionEnum == ActionEnum.NONE) {
          this.actionEnum = ActionEnum.SHOOT;
          try {
            //String element = scan.next();
            if (!this.dungeon.isGameOver()) {
              String shootString = dungeon.shootArrow(distance, direction);
              view.updateStatus(shootString);
              view.getUpdater(dungeon.getStatusUpdater());
            }
            this.direction = Direction.NONE;
            this.actionEnum = ActionEnum.NONE;
            view.makeVisible();
            view.refresh();
            view.resetFocus();
          } catch (IllegalArgumentException iae) {
            this.actionEnum = ActionEnum.NONE;
            this.direction = Direction.NONE;
            this.pickup = PickupEnum.NONE;
          }
        }
        this.actionEnum = ActionEnum.NONE;
        this.pickup = PickupEnum.NONE;
        this.direction = Direction.NONE;
        view.resetFocus();
        break;

      case "Pickup Button":
        while (!this.dungeon.isGameOver()) {
          if (actionEnum == ActionEnum.NONE) {
            this.actionEnum = ActionEnum.PICKUP;
            try {
              int temp = 0;
              if (pickup == PickupEnum.TREASURE) {
                //do nothing temp already set
              } else if (pickup == PickupEnum.ARROW) {
                temp = 1;
              } else {
                temp = 2;
              }
              if (!this.dungeon.isGameOver()) {
                String pickupString = dungeon.pickUpItem(temp);
                view.updateStatus(pickupString);
                view.getUpdater(dungeon.getStatusUpdater());
              }
              this.pickup = PickupEnum.NONE;
              this.actionEnum = ActionEnum.NONE;
              view.makeVisible();
              view.refresh();
              view.resetFocus();
            } catch (IllegalArgumentException iae) {
              this.actionEnum = ActionEnum.NONE;
              this.direction = Direction.NONE;
              this.pickup = PickupEnum.NONE;
            }
          }
          this.actionEnum = ActionEnum.NONE;
          this.pickup = PickupEnum.NONE;
          this.direction = Direction.NONE;
          view.resetFocus();
        }
        break;

      case "Build Button":
        view.resetFocus();
        BuildStructure newDungeon = view.getBuilder();
        try {
          Player player = new PlayerImpl();
          this.currentSeed = rand.getRandomNumber(0, 200);
          Dungeon freshDungeon = new DungeonImpl(newDungeon.getWraps(), newDungeon.getRows(),
                  newDungeon.getCols(), newDungeon.getInter(), newDungeon.getTreas(), player,
                  newDungeon.getDiff(), this.currentSeed);
          this.startString = freshDungeon.getDungeon();
          view.setModel(freshDungeon);
          this.dungeon = freshDungeon;
          this.actionEnum = ActionEnum.NONE;
          this.direction = Direction.NONE;
          this.pickup = PickupEnum.NONE;
          this.distance = 0;
          this.dungeon = freshDungeon;
          this.startUpdate = freshDungeon.getStatusUpdater();
          view.updateStatus(this.startString);
          view.getUpdater(dungeon.getStatusUpdater());
          view.makeVisible();
          view.resetFocus();
          view.refresh();
        } catch (IllegalArgumentException iae) {
          view.updateStatus("Dungeon Couldn't be created enjoy this one or try again");
          this.restartDungeon();
        } catch (IllegalStateException ise) {
          view.updateStatus("Dungeon Couldn't be created enjoy this one or try again");
          this.restartDungeon();
        }
        break;

      case "Quit Game":
        this.dungeon.quitGame();
        System.exit(0);
        break;

      case "Restart New Dungeon":
        try {
          Player player = new PlayerImpl();
          this.currentSeed = rand.getRandomNumber(0, 200);
          Dungeon freshDungeon = new DungeonImpl(this.dungeon.getWrapping(),
                  this.dungeon.getGameBoardRows(), this.dungeon.getGameBoardCols(),
                  this.dungeon.getInterConnect(), this.dungeon.getTreasurePer(), player,
                  this.dungeon.getDifficulty(), this.currentSeed);

          this.startString = freshDungeon.getDungeon();
          view.setModel(freshDungeon);
          this.dungeon = freshDungeon;
          this.actionEnum = ActionEnum.NONE;
          this.direction = Direction.NONE;
          this.pickup = PickupEnum.NONE;
          this.distance = 0;
          this.dungeon = freshDungeon;
          this.startUpdate = freshDungeon.getStatusUpdater();
          view.updateStatus(this.startString);
          view.getUpdater(dungeon.getStatusUpdater());
          view.makeVisible();
          view.resetFocus();
          view.refresh();


        } catch (IllegalArgumentException iae) {
          view.updateStatus("Dungeon Couldn't be created enjoy this one or try again");
          this.restartDungeon();
        } catch (IllegalStateException ise) {
          view.updateStatus("Dungeon Couldn't be created enjoy this one or try again");
          this.restartDungeon();
        }
        break;

      case "Restart Same Dungeon":
        try {
          Player player = new PlayerImpl();
          Dungeon freshDungeon = new DungeonImpl(this.dungeon.getWrapping(),
                  this.dungeon.getGameBoardRows(), this.dungeon.getGameBoardCols(),
                  this.dungeon.getInterConnect(), this.dungeon.getTreasurePer(), player,
                  this.dungeon.getDifficulty(), this.dungeon.getSeed());
          this.startString = freshDungeon.getDungeon();
          view.setModel(freshDungeon);
          this.dungeon = freshDungeon;
          this.actionEnum = ActionEnum.NONE;
          this.direction = Direction.NONE;
          this.pickup = PickupEnum.NONE;
          this.distance = 0;
          this.startUpdate = freshDungeon.getStatusUpdater();
          view.updateStatus(this.startString);
          view.getUpdater(dungeon.getStatusUpdater());
          view.makeVisible();
          view.resetFocus();
          view.refresh();
        } catch (IllegalArgumentException iae) {
          view.updateStatus("Dungeon Couldn't be created enjoy this one or try again");
          this.restartDungeon();
        } catch (IllegalStateException ise) {
          view.updateStatus("Dungeon Couldn't be created enjoy this one or try again");
          this.restartDungeon();
        }
        break;
      default: throw new IllegalArgumentException("No such button or key");
    }
  }

  /**
   * Invoked when a key has been typed.
   * See the class description for {@link KeyEvent} for a definition of
   * a key typed event.
   *
   * @param e the event to be processed
   */
  @Override
  public void keyTyped(KeyEvent e) {
    int keyCode = e.getKeyCode();
    switch (keyCode) {
      case KeyEvent.VK_UP:
        if (direction == Direction.NONE) {
          this.direction = Direction.NORTH;
        } else {
          this.direction = Direction.NONE;
          this.actionEnum = ActionEnum.NONE;
          this.pickup = PickupEnum.NONE;
        }
        break;
      case KeyEvent.VK_DOWN:
        if (direction == Direction.NONE) {
          this.direction = Direction.SOUTH;
        } else {
          this.direction = Direction.NONE;
          this.actionEnum = ActionEnum.NONE;
          this.pickup = PickupEnum.NONE;
        }
        break;
      case KeyEvent.VK_LEFT:
        if (direction == Direction.NONE) {
          this.direction = Direction.WEST;
        } else {
          this.direction = Direction.NONE;
          this.actionEnum = ActionEnum.NONE;
          this.pickup = PickupEnum.NONE;
        }
        break;
      case KeyEvent.VK_RIGHT:
        if (direction == Direction.NONE) {
          this.direction = Direction.EAST;
        } else {
          this.direction = Direction.NONE;
          this.actionEnum = ActionEnum.NONE;
          this.pickup = PickupEnum.NONE;
        }
        break;
      default: break;
    }
    if (e.getKeyChar() == 'm') {
      if (actionEnum == ActionEnum.NONE) {
        this.actionEnum = ActionEnum.MOVE;
        try {
          if (!this.dungeon.isGameOver()) {
            String moveString = dungeon.movePlayer(direction);
            view.updateStatus(moveString);
            view.getUpdater(dungeon.getStatusUpdater());
          }
          this.direction = Direction.NONE;
          this.actionEnum = ActionEnum.NONE;
          view.makeVisible();
          view.refresh();
          view.resetFocus();
        } catch (IllegalArgumentException iae) {
          this.actionEnum = ActionEnum.NONE;
          this.direction = Direction.NONE;
          this.pickup = PickupEnum.NONE;
        }
      }

      this.actionEnum = ActionEnum.NONE;
      this.pickup = PickupEnum.NONE;
      this.direction = Direction.NONE;
      view.resetFocus();
    } else if (e.getKeyChar() == 's') {
      if (actionEnum == ActionEnum.NONE) {
        this.actionEnum = ActionEnum.SHOOT;
        try {
          if (!this.dungeon.isGameOver()) {
            String shootString = dungeon.shootArrow(distance, direction);
            view.updateStatus(shootString);
            view.getUpdater(dungeon.getStatusUpdater());
          }
          this.direction = Direction.NONE;
          this.actionEnum = ActionEnum.NONE;
          view.makeVisible();
          view.refresh();
          view.resetFocus();
        } catch (IllegalArgumentException iae) {
          this.actionEnum = ActionEnum.NONE;
          this.direction = Direction.NONE;
          this.pickup = PickupEnum.NONE;
        }
      }
      this.actionEnum = ActionEnum.NONE;
      this.pickup = PickupEnum.NONE;
      this.direction = Direction.NONE;
      view.resetFocus();
    } else if (e.getKeyChar() == 'p') {
      if (actionEnum == ActionEnum.NONE) {
        this.actionEnum = ActionEnum.PICKUP;
        try {
          int temp = 0;
          if (pickup == PickupEnum.TREASURE) {
            //temp already set
          } else if (pickup == PickupEnum.ARROW) {
            temp = 1;
          } else {
            temp = 2;
          }
          if (!this.dungeon.isGameOver()) {
            String pickupString = dungeon.pickUpItem(temp);
            view.updateStatus(pickupString);
            view.getUpdater(dungeon.getStatusUpdater());
          }
          this.pickup = PickupEnum.NONE;
          this.actionEnum = ActionEnum.NONE;
          view.makeVisible();
          view.refresh();
          view.resetFocus();
        } catch (IllegalArgumentException iae) {
          this.actionEnum = ActionEnum.NONE;
          this.direction = Direction.NONE;
          this.pickup = PickupEnum.NONE;
        }
      }
      this.actionEnum = ActionEnum.NONE;
      this.pickup = PickupEnum.NONE;
      this.direction = Direction.NONE;
      view.resetFocus();
    } else if (e.getKeyChar() == 'a') {
      if (pickup == PickupEnum.NONE) {
        this.pickup = PickupEnum.ARROW;
      } else {
        this.direction = Direction.NONE;
        this.actionEnum = ActionEnum.NONE;
        this.pickup = PickupEnum.NONE;
      }
    } else if (e.getKeyChar() == 't') {
      if (pickup == PickupEnum.NONE) {
        this.pickup = PickupEnum.TREASURE;
      } else {
        this.direction = Direction.NONE;
        this.actionEnum = ActionEnum.NONE;
        this.pickup = PickupEnum.NONE;
      }
    } else if (e.getKeyChar() == 'b') {
      if (pickup == PickupEnum.NONE) {
        this.pickup = PickupEnum.BOTH;
      } else {
        this.direction = Direction.NONE;
        this.actionEnum = ActionEnum.NONE;
        this.pickup = PickupEnum.NONE;
      }
    } else if (e.getKeyChar() == 'q') {
      this.dungeon.quitGame();
      System.exit(0);
    } else if (e.getKeyChar() == '1') {
      if (this.distance == 0) {
        this.distance = 1;
      }
    } else if (e.getKeyChar() == '2') {
      if (this.distance == 0) {
        this.distance = 2;
      }
    } else if (e.getKeyChar() == '3') {
      if (this.distance == 0) {
        this.distance = 3;
      }
    } else if (e.getKeyChar() == '4') {
      if (this.distance == 0) {
        this.distance = 4;
      }
    }
  }

  /**
   * Invoked when a key has been pressed.
   * See the class description for {@link KeyEvent} for a definition of
   * a key pressed event.
   *
   * @param e the event to be processed
   */
  @Override
  public void keyPressed(KeyEvent e) {

    int keyCode = e.getKeyCode();
    switch (keyCode) {
      case KeyEvent.VK_UP:
        if (direction == Direction.NONE) {
          this.direction = Direction.NORTH;
        }
        break;
      case KeyEvent.VK_DOWN:
        if (direction == Direction.NONE) {
          this.direction = Direction.SOUTH;
        }
        break;
      case KeyEvent.VK_LEFT:
        if (direction == Direction.NONE) {
          this.direction = Direction.WEST;
        }
        break;
      case KeyEvent.VK_RIGHT:
        if (direction == Direction.NONE) {
          this.direction = Direction.EAST;
        }
        break;
      default: break;
    }
  }

  /**
   * Invoked when a key has been released.
   * See the class description for {@link KeyEvent} for a definition of
   * a key released event.
   *
   * @param e the event to be processed
   */
  @Override
  public void keyReleased(KeyEvent e) {
    //this method is not used because there are no behaviours dependent on key releases
  }

  @Override
  public void restartDungeon() {
    int curDungeonRows = this.dungeon.getGameBoardRows();
    int curDungeonCols = this.dungeon.getGameBoardCols();
    int curDungeonTreas = this.dungeon.getTreasurePer();
    int curDungeonInt = this.dungeon.getInterConnect();
    int curDungeonDif = this.dungeon.getDifficulty();
    boolean curDungeonWraps = this.dungeon.getWraps();
    int curDungeonSeed = this.dungeon.getSeed();
    Player newPlayer = new PlayerImpl();
    Dungeon newDungeon = new DungeonImpl(curDungeonWraps, curDungeonRows, curDungeonCols,
            curDungeonInt, curDungeonTreas, newPlayer, curDungeonDif, curDungeonSeed);


    this.startString = newDungeon.getDungeon();
    this.startUpdate = newDungeon.getStatusUpdater();
    view.updateStatus(this.startString);
    view.getUpdater(newDungeon.getStatusUpdater());
    this.view.makeVisible();
    this.view.refresh();
    this.view.resetFocus();
    this.dungeon = newDungeon;
    this.playGame(newDungeon, this.view);
  }

  /**
   * Handle an action in a single cell of the board, such as to make a move.
   *
   * @param row the row of the clicked cell
   * @param col the column of the clicked cell
   */
  @Override
  public void handleCellClick(int row, int col) {
    System.out.println("Player clicked here: " + row + " " + col);
  }
}
